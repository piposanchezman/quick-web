---
/**
 * UptimeStatus Component
 * Displays server uptime information from Uptime Robot API
 * Uses API-provided percentages for accuracy
 */

interface Props {
  apiKey?: string;
  monitorId?: string;
}

const { apiKey, monitorId } = Astro.props;
---

<div
  id="uptime-status"
  class="bg-black/20 p-6 rounded-2xl border border-white/5 hover:border-[#33cccc]/30 transition-colors"
>
  <!-- Loading State -->
  <div id="uptime-loading" class="text-center">
    <div class="animate-pulse">
      <div
        class="text-4xl font-black text-[#33cccc] mb-2 drop-shadow-[0_0_10px_rgba(51,204,204,0.4)]"
      >
        --.--%
      </div>
      <div
        class="text-sm text-gray-400 uppercase tracking-wider font-bold mb-4"
        data-i18n="about.uptime"
      >
      </div>
      <div class="flex flex-col gap-2">
        <div class="flex gap-1 justify-center items-end h-8">
          {Array.from({ length: 7 }).map(() => (
            <div class="w-6 h-4 bg-gray-700 rounded-sm animate-pulse" />
          ))}
        </div>
      </div>
      <div class="text-xs text-gray-500 mt-1" data-i18n="about.uptimeDays">
      </div>
    </div>
  </div>

  <!-- Content (hidden initially) -->
  <div id="uptime-content" class="hidden">
    <div
      id="uptime-percentage"
      class="text-4xl font-black text-[#33cccc] mb-2 drop-shadow-[0_0_10px_rgba(51,204,204,0.4)] text-center"
    >
      99.9%
    </div>
    <div
      class="text-sm text-gray-400 uppercase tracking-wider font-bold mb-4 text-center"
      data-i18n="about.uptime"
    >
    </div>

    <!-- Period Selector -->
    <div class="flex gap-2 justify-center mb-4">
      <button
        data-period="1"
        class="uptime-period-btn px-3 py-1 text-xs rounded-lg bg-[#33cccc]/20 text-[#33cccc] border border-[#33cccc]/30 hover:bg-[#33cccc]/30 transition-colors active"
      >
        24h
      </button>
      <button
        data-period="7"
        class="uptime-period-btn px-3 py-1 text-xs rounded-lg bg-black/20 text-gray-400 border border-white/10 hover:bg-white/5 transition-colors"
      >
        7d
      </button>
      <button
        data-period="30"
        class="uptime-period-btn px-3 py-1 text-xs rounded-lg bg-black/20 text-gray-400 border border-white/10 hover:bg-white/5 transition-colors"
      >
        30d
      </button>
      <button
        data-period="365"
        class="uptime-period-btn px-3 py-1 text-xs rounded-lg bg-black/20 text-gray-400 border border-white/10 hover:bg-white/5 transition-colors"
      >
        12m
      </button>
    </div>

    <!-- Uptime Bars -->
    <div id="uptime-bars-container" class="flex justify-center">
      <!-- Bars will be injected here -->
    </div>
    <div
      id="uptime-period-label"
      class="text-xs text-gray-500 mt-4 text-center"
      data-i18n="about.last24hours"
    >
    </div>
    <div class="text-[10px] text-gray-600 text-center mt-1">
      <span data-i18n="about.timezone"></span>: <span id="timezone-label">--</span>
    </div>
    <!-- Monitoring age warning -->
    <div id="monitoring-warning" class="hidden text-xs text-yellow-400/80 text-center mt-2 flex items-center justify-center gap-1">
      <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
      </svg>
      <span id="monitoring-warning-text"></span>
    </div>
  </div>

  <!-- Error State -->
  <div id="uptime-error" class="hidden text-center">
    <div
      class="text-4xl font-black text-[#33cccc] mb-2 drop-shadow-[0_0_10px_rgba(51,204,204,0.4)]"
    >
      99.9%
    </div>
    <div
      class="text-sm text-gray-400 uppercase tracking-wider font-bold"
      data-i18n="about.uptime"
    >
    </div>
  </div>
</div>

<script>
  interface UptimeRobotResponse {
    stat: string;
    monitors: Array<{
      status: number;
      create_datetime: number;
      custom_uptime_ratio: string;
      custom_down_durations: string;
      logs?: Array<{
        type: number;
        datetime: number;
        duration: number;
      }>;
    }>;
  }

  interface PeriodData {
    percentage: number;
    isComplete: boolean;
    downDuration: number;
  }

  // Get exact time since monitoring started in human readable format
  function getExactTimeSinceStart(createDatetime: number): string {
    const now = Date.now() / 1000;
    const secondsSince = now - createDatetime;
    const days = Math.floor(secondsSince / (24 * 60 * 60));
    const hours = Math.floor((secondsSince % (24 * 60 * 60)) / (60 * 60));
    const minutes = Math.floor((secondsSince % (60 * 60)) / 60);
    
    // @ts-ignore
    const getI18n = window.getI18n || ((key: string) => key);
    const daysText = days !== 1 ? getI18n('about.time.days') : getI18n('about.time.day');
    const hoursText = getI18n('about.time.hours');
    const minutesText = getI18n('about.time.minutes');
    
    if (days > 0) {
      return `${days} ${daysText}, ${hours}${hoursText} ${minutes}${minutesText}`;
    } else if (hours > 0) {
      return `${hours}${hoursText} ${minutes}${minutesText}`;
    } else {
      return `${minutes} ${minutesText}`;
    }
  }

  // Get formatted start date
  function getMonitoringStartDate(createDatetime: number): string {
    const date = new Date(createDatetime * 1000);
    // @ts-ignore
    const locale = window.currentLocale || 'es';
    const localeMap: Record<string, string> = { es: 'es-MX', en: 'en-US', pt: 'pt-BR' };
    return date.toLocaleDateString(localeMap[locale] || 'es-MX', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });
  }

  // Parse uptime ratios from API and calculate exact uptime for each period
  // Uses exact monitoring start time (not rounded to days)
  function parseUptimeRatios(
    ratioString: string,
    downDurationsString: string,
    createDatetime: number
  ): Map<number, PeriodData> {
    const ratios = ratioString.split('-').map(parseFloat);
    const downDurations = downDurationsString.split('-').map(parseFloat);
    const now = Date.now() / 1000;
    const secondsSinceStart = now - createDatetime;
    
    const periods = [1, 7, 30, 365];
    const result = new Map<number, PeriodData>();
    
    periods.forEach((period, index) => {
      const periodSeconds = period * 24 * 60 * 60;
      const isComplete = secondsSinceStart >= periodSeconds;
      
      // Calculate uptime based on exact time since monitoring started
      const actualPercentage = isComplete 
        ? ratios[index] || 99.9
        : ((secondsSinceStart - (downDurations[index] || 0)) / secondsSinceStart) * 100;
      
      result.set(period, {
        percentage: actualPercentage,
        isComplete,
        downDuration: downDurations[index] || 0
      });
    });
    
    return result;
  }

  // Calculate bar values based on actual downtime events from logs
  // Returns null for days before monitoring started
  function calculatePeriodBarsFromLogs(
    period: number,
    logs: Array<{ type: number; datetime: number; duration: number }>,
    createDatetime: number
  ): (number | null)[] {
    const now = Date.now() / 1000;
    const numBars = period >= 365 ? 12 : Math.min(period, 30);
    const bars: (number | null)[] = [];
    
    // Calculate start time based on period
    let startTime: number;
    
    if (period >= 365) {
      const startDate = new Date();
      startDate.setMonth(startDate.getMonth() - 11);
      startDate.setDate(1);
      startDate.setHours(0, 0, 0, 0);
      startTime = startDate.getTime() / 1000;
    } else {
      const daysToShow = Math.min(period, 30);
      startTime = now - (daysToShow * 24 * 60 * 60);
    }
    
    // Process each bar period
    for (let i = 0; i < numBars; i++) {
      let barStart: number;
      let barEnd: number;
      let currentBarDuration: number;
      
      if (period >= 365) {
        // Monthly periods
        const barDate = new Date();
        barDate.setMonth(barDate.getMonth() - (11 - i));
        barDate.setDate(1);
        barDate.setHours(0, 0, 0, 0);
        barStart = barDate.getTime() / 1000;
        
        const nextMonth = new Date(barDate);
        nextMonth.setMonth(nextMonth.getMonth() + 1);
        barEnd = Math.min(nextMonth.getTime() / 1000, now);
        currentBarDuration = barEnd - barStart;
      } else {
        // Daily periods
        barStart = startTime + (i * 24 * 60 * 60);
        barEnd = Math.min(barStart + (24 * 60 * 60), now);
        currentBarDuration = barEnd - barStart;
      }
      
      // Check if this period is before monitoring started
      if (barEnd <= createDatetime) {
        bars.push(null); // No monitoring data
        continue;
      }
      
      // If monitoring started during this period, adjust
      if (barStart < createDatetime) {
        barStart = createDatetime;
        currentBarDuration = barEnd - barStart;
      }
      
      // Find DOWN events in this period
      const barDownEvents = logs.filter(
        log => log.type === 1 && log.datetime >= barStart && log.datetime < barEnd
      );
      
      if (barDownEvents.length > 0) {
        // Calculate total downtime in this bar
        const totalDowntime = barDownEvents.reduce((sum, log) => sum + log.duration, 0);
        const uptimeSeconds = currentBarDuration - totalDowntime;
        const uptimePercentage = (uptimeSeconds / currentBarDuration) * 100;
        bars.push(Math.max(0, Math.min(100, uptimePercentage)));
      } else {
        bars.push(100); // Full uptime
      }
    }
    
    return bars;
  }

  // Calculate uptime from logs for 24h view (exact hour:minute window)
  function calculateHourlyUptime(
    logs: Array<{ type: number; datetime: number; duration: number }>
  ): number[] {
    const now = Date.now() / 1000;
    const startTime = now - (24 * 60 * 60);
    const lookbackLogs = logs.filter(log => log.datetime >= startTime - (24 * 60 * 60));
    const hourlyStatus: number[] = [];

    for (let i = 0; i < 24; i++) {
      const barStart = startTime + (i * 3600);
      const barEnd = barStart + 3600;
      let uptimeSeconds = 3600;

      // Check for carry-over downtime from before this bar
      const lastDown = [...lookbackLogs].reverse().find(
        log => log.type === 1 && log.datetime < barStart
      );

      if (lastDown) {
        const upAfter = lookbackLogs.find(
          l => l.type === 2 && l.datetime > lastDown.datetime && l.datetime < barStart
        );

        if (!upAfter) {
          const laterUp = lookbackLogs.find(
            l => l.type === 2 && l.datetime > lastDown.datetime
          );
          if (laterUp && laterUp.datetime < barEnd) {
            uptimeSeconds -= laterUp.datetime - barStart;
          } else if (!laterUp || laterUp.datetime >= barEnd) {
            uptimeSeconds = 0;
          }
        }
      }

      // Process DOWN events within this bar
      const barLogs = lookbackLogs
        .filter(log => log.datetime >= barStart && log.datetime < barEnd)
        .sort((a, b) => a.datetime - b.datetime);

      for (let j = 0; j < barLogs.length; j++) {
        if (barLogs[j].type === 1) {
          const downStart = barLogs[j].datetime;
          let downEnd = barEnd;

          for (let k = j + 1; k < barLogs.length; k++) {
            if (barLogs[k].type === 2) {
              downEnd = Math.min(barLogs[k].datetime, barEnd);
              break;
            }
          }
          uptimeSeconds -= downEnd - downStart;
        }
      }

      hourlyStatus.push(Math.max(0, Math.min(100, (uptimeSeconds / 3600) * 100)));
    }

    return hourlyStatus;
  }

  // Get color based on uptime percentage
  function getUptimeColor(percentage: number): string {
    if (percentage >= 100) return "#33CCCC"; // Cyan base - 100%
    if (percentage >= 90) return "#41BDBD";
    if (percentage >= 80) return "#4FAEAE";
    if (percentage >= 70) return "#5D9F9F";
    if (percentage >= 60) return "#6B9090";
    if (percentage >= 50) return "#7A7A7A"; // Punto medio neutro
    if (percentage >= 40) return "#896363";
    if (percentage >= 30) return "#974C4C";
    if (percentage >= 20) return "#A53535";
    if (percentage >= 10) return "#B31E1E";
    return "#DD4444"; // Rojo final
  }

  // Create visualization bars
  function createUptimeBars(barValues: (number | null)[], period: number): string {
    const numBars = barValues.length;
    let numRows = 1;
    let barsPerRow = numBars;

    if (period === 1) {
      numRows = 2;
      barsPerRow = 12;
    } else if (period === 30) {
      numRows = 2;
      barsPerRow = 15;
    }

    const totalHeight = 140;
    const gapHeight = 8;
    const rowHeight =
      numRows === 1 ? totalHeight : (totalHeight - gapHeight) / 2;

    const labels = getBarLabels(period);

    let html = numRows === 1 ? '' : '<div class="flex flex-col gap-2 w-full">';

    for (let row = 0; row < numRows; row++) {
      const startIdx = row * barsPerRow;
      const endIdx = Math.min(startIdx + barsPerRow, numBars);
      const rowBars = barValues.slice(startIdx, endIdx);

      html += `<div class="flex gap-1 items-end w-full" style="height: ${rowHeight}px;">`;

      rowBars.forEach((uptime, idx) => {
        const index = startIdx + idx;
        const label = labels[index] || '';

        // Si no hay datos (null), mostrar barra vacÃ­a
        if (uptime === null) {
          // @ts-ignore
          const getI18n = window.getI18n || ((key: string) => key);
          const noDataText = getI18n('about.monitoring.noData');
          
          html += `
            <div class="flex flex-col items-center justify-end gap-1" style="flex: 1; height: 100%; min-width: 0;">
              <div 
                class="w-full rounded-t flex items-center justify-center relative"
                style="background-color: #333; height: 10%; opacity: 0.3;"
                title="${noDataText}"
              >
              </div>
              <div class="text-[8px] text-gray-600 font-semibold text-center leading-tight whitespace-nowrap overflow-hidden text-ellipsis w-full">
                ${label}
              </div>
            </div>
          `;
        } else {
          const color = getUptimeColor(uptime);
          const height = Math.max(uptime, 10);
          const opacity = uptime >= 95 ? 1 : 0.6;

          html += `
            <div class="flex flex-col items-center justify-end gap-1 uptime-bar-wrapper" style="flex: 1; height: 100%; min-width: 0;">
              <div 
                class="w-full rounded-t flex items-center justify-center relative transition-all duration-200 cursor-pointer uptime-bar"
                style="background-color: ${color}; height: ${height}%; opacity: ${opacity};"
                data-uptime="${uptime.toFixed(2)}"
              >
                <span class="text-[10px] font-bold text-white opacity-0 transition-opacity duration-200 bg-black/60 px-1 py-1 rounded whitespace-nowrap uptime-tooltip" style="writing-mode: vertical-rl;">
                  ${uptime.toFixed(2)}%
                </span>
              </div>
              <div class="text-[8px] text-gray-400 font-semibold text-center leading-tight whitespace-nowrap overflow-hidden text-ellipsis w-full">
                ${label}
              </div>
            </div>
          `;
        }
      });

      html += '</div>';
    }

    if (numRows > 1) html += '</div>';

    return html;
  }

  // Get bar labels for period
  function getBarLabels(period: number): string[] {
    const labels: string[] = [];
    const now = new Date();

    if (period === 1) {
      // For 24h: show exact hour:minute for all bars
      const currentTime = now.getTime();
      const startTime = currentTime - (24 * 60 * 60 * 1000); // 24 hours ago
      
      for (let i = 0; i < 24; i++) {
        const barTime = new Date(startTime + (i * 60 * 60 * 1000));
        const hour = barTime.getHours();
        const minutes = barTime.getMinutes();
        labels.push(`${hour.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`);
      }
    } else if (period <= 30) {
      const numBars = Math.min(period, 30);
      for (let i = numBars - 1; i >= 0; i--) {
        const date = new Date(now);
        date.setDate(date.getDate() - i);
        const day = date.getDate().toString().padStart(2, '0');
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        labels.push(`${day}/${month}`);
      }
    } else {
      // @ts-ignore
      const getI18n = window.getI18n || ((key: string) => key);
      const monthKeys = [
        getI18n('about.months.jan'),
        getI18n('about.months.feb'),
        getI18n('about.months.mar'),
        getI18n('about.months.apr'),
        getI18n('about.months.may'),
        getI18n('about.months.jun'),
        getI18n('about.months.jul'),
        getI18n('about.months.aug'),
        getI18n('about.months.sep'),
        getI18n('about.months.oct'),
        getI18n('about.months.nov'),
        getI18n('about.months.dec')
      ];
      for (let i = 11; i >= 0; i--) {
        const date = new Date(now);
        date.setMonth(date.getMonth() - i);
        labels.push(monthKeys[date.getMonth()]);
      }
    }

    return labels;
  }

  // Main state
  let currentPeriod = 1;
  let cachedData: UptimeRobotResponse | null = null;
  let lastFetchTime = 0;
  let fetchInterval: number | null = null;
  const REFETCH_INTERVAL = 5 * 60 * 1000; // 5 minutes
  const MIN_FETCH_INTERVAL = 30 * 1000; // 30 seconds minimum between requests

  // Fetch and display uptime (respects rate limits)
  async function fetchUptimeStatus(forceRefresh = false) {
    const loadingEl = document.getElementById("uptime-loading");
    const contentEl = document.getElementById("uptime-content");
    const errorEl = document.getElementById("uptime-error");
    const percentageEl = document.getElementById("uptime-percentage");
    const barsEl = document.getElementById("uptime-bars-container");
    const warningEl = document.getElementById("monitoring-warning");
    const warningTextEl = document.getElementById("monitoring-warning-text");

    const now = Date.now();
    
    // Use cached data if available and recent (unless force refresh)
    if (!forceRefresh && cachedData && (now - lastFetchTime) < MIN_FETCH_INTERVAL) {
      console.log('[UptimeStatus] Using cached data to avoid rate limit');
      updateDisplay(cachedData);
      return;
    }

    try {
      const response = await fetch(`/api/uptime?days=${currentPeriod}`);
      
      if (response.status === 429) {
        console.warn('[UptimeStatus] Rate limit hit, using cached data');
        if (cachedData) {
          updateDisplay(cachedData);
        }
        return;
      }
      
      if (!response.ok) throw new Error(`API error: ${response.status}`);

      const data: UptimeRobotResponse | { error: string } = await response.json();

      if ("error" in data) {
        console.warn('[UptimeStatus] API error:', data.error);
        if (cachedData) {
          updateDisplay(cachedData);
        } else {
          throw new Error(data.error);
        }
        return;
      }

      if (data.stat === "ok" && data.monitors?.length > 0) {
        cachedData = data;
        lastFetchTime = now;
        updateDisplay(data);
      }
    } catch (error) {
      console.error("[UptimeStatus] Error:", error);
      if (cachedData) {
        console.log('[UptimeStatus] Falling back to cached data');
        updateDisplay(cachedData);
      } else {
        if (loadingEl) loadingEl.classList.add("hidden");
        if (errorEl) errorEl.classList.remove("hidden");
      }
    }
  }

  // Update display with data
  function updateDisplay(data: UptimeRobotResponse) {
    const loadingEl = document.getElementById("uptime-loading");
    const contentEl = document.getElementById("uptime-content");
    const percentageEl = document.getElementById("uptime-percentage");
    const barsEl = document.getElementById("uptime-bars-container");
    const warningEl = document.getElementById("monitoring-warning");
    const warningTextEl = document.getElementById("monitoring-warning-text");

    const monitor = data.monitors[0];

    // Parse all periods from API
    const periodData = parseUptimeRatios(
      monitor.custom_uptime_ratio,
      monitor.custom_down_durations,
      monitor.create_datetime
    );

    const current = periodData.get(currentPeriod)!;
    let barValues: (number | null)[];

    // For all periods, use logs to show downtimes in specific bars
    if (currentPeriod === 1) {
      // 24h view: hourly precision
      barValues = monitor.logs && monitor.logs.length > 0
        ? calculateHourlyUptime(monitor.logs)
        : Array(24).fill(100);
    } else {
      // 7d, 30d, 12m: daily/monthly precision from logs
      barValues = monitor.logs && monitor.logs.length > 0
        ? calculatePeriodBarsFromLogs(currentPeriod, monitor.logs, monitor.create_datetime)
        : Array(currentPeriod >= 365 ? 12 : Math.min(currentPeriod, 30)).fill(100);
    }

    // Update percentage display
    if (percentageEl) {
      percentageEl.textContent = `${current.percentage.toFixed(3)}%`;
      const color = getUptimeColor(current.percentage);
      percentageEl.style.color = color;
      percentageEl.style.textShadow = `0 0 10px ${color}40`;
    }

    // Update bars
    if (barsEl) {
      barsEl.innerHTML = createUptimeBars(barValues, currentPeriod);
    }

    // Show warning if period is incomplete
    if (warningEl && warningTextEl) {
      if (!current.isComplete) {
        const startDate = getMonitoringStartDate(monitor.create_datetime);
        const exactTime = getExactTimeSinceStart(monitor.create_datetime);
        // @ts-ignore
        const getI18n = window.getI18n || ((key: string) => key);
        const monitoringSinceText = getI18n('about.monitoring.since');
        warningTextEl.textContent = `${monitoringSinceText} ${startDate} (${exactTime})`;
        warningEl.classList.remove('hidden');
      } else {
        warningEl.classList.add('hidden');
      }
    }

    // Show content
    if (loadingEl) loadingEl.classList.add("hidden");
    if (contentEl) contentEl.classList.remove("hidden");
  }

  // Init
  document.addEventListener("DOMContentLoaded", () => {
    // Timezone
    const tzLabel = document.getElementById('timezone-label');
    if (tzLabel) {
      const offset = -new Date().getTimezoneOffset() / 60;
      tzLabel.textContent = `GMT${offset >= 0 ? '+' : ''}${offset}`;
    }

    // Initial fetch
    fetchUptimeStatus(true);
    
    // Set up interval for auto-refresh every 5 minutes
    if (fetchInterval) clearInterval(fetchInterval);
    fetchInterval = window.setInterval(() => {
      fetchUptimeStatus(false);
    }, REFETCH_INTERVAL);

    // Refresh when page becomes visible (respecting rate limits)
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        const timeSinceLastFetch = Date.now() - lastFetchTime;
        if (timeSinceLastFetch > MIN_FETCH_INTERVAL) {
          fetchUptimeStatus(false);
        }
      }
    });

    // Period buttons
    document.querySelectorAll('.uptime-period-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        const period = parseInt(btn.getAttribute('data-period') || '1');
        currentPeriod = period;

        document.querySelectorAll('.uptime-period-btn').forEach((b) => {
          b.classList.remove('active', 'bg-[#33cccc]/20', 'text-[#33cccc]', 'border-[#33cccc]/30');
          b.classList.add('bg-black/20', 'text-gray-400', 'border-white/10');
        });
        btn.classList.add('active', 'bg-[#33cccc]/20', 'text-[#33cccc]', 'border-[#33cccc]/30');
        btn.classList.remove('bg-black/20', 'text-gray-400', 'border-white/10');

        const labelEl = document.getElementById('uptime-period-label');
        if (labelEl) {
          const labels: Record<number, string> = {
            1: 'about.last24hours',
            7: 'about.last7days',
            30: 'about.last30days',
            365: 'about.last12months',
          };
          labelEl.setAttribute('data-i18n', labels[period]);
          // @ts-ignore
          labelEl.textContent = window.getI18n?.(labels[period]) || '';
        }

        fetchUptimeStatus();
      });
    });

    // Add hover effects to uptime bars
    document.addEventListener('mouseover', (e) => {
      const target = e.target as HTMLElement;
      const bar = target.closest('.uptime-bar');
      if (bar) {
        const tooltip = bar.querySelector('.uptime-tooltip');
        if (tooltip) {
          tooltip.classList.remove('opacity-0');
          tooltip.classList.add('opacity-100');
        }
        // Scale effect
        (bar as HTMLElement).style.transform = 'scaleX(1.05)';
        (bar as HTMLElement).style.filter = 'brightness(1.2)';
      }
    });

    document.addEventListener('mouseout', (e) => {
      const target = e.target as HTMLElement;
      const bar = target.closest('.uptime-bar');
      if (bar) {
        const tooltip = bar.querySelector('.uptime-tooltip');
        if (tooltip) {
          tooltip.classList.add('opacity-0');
          tooltip.classList.remove('opacity-100');
        }
        // Remove scale effect
        (bar as HTMLElement).style.transform = '';
        (bar as HTMLElement).style.filter = '';
      }
    });
  });
</script>

<style>
  .uptime-bar {
    transition: transform 0.2s ease, filter 0.2s ease;
  }

  .uptime-bar:hover {
    z-index: 10;
  }

  .uptime-tooltip {
    pointer-events: none;
  }
</style>
